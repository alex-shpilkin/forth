s" shim.ans" included   hex

variable \stack
: stack    \stack @ ;
: change   \stack @ 1 cells + ;
: get      \stack @ 2 cells + ;
: put      \stack @ 3 cells + ;

label rstack   72 , 3 cells allot   : R:   rstack \stack ! ;
label dstack   64 , 3 cells allot   : D:   dstack \stack ! ;

variable pops   label pushing   true ,

: clip ( a n m -- a+m n-m )   tuck - tor + swap ;

: string, ( a n -- )
  begin   dup while   over c@ c,   1 clip repeat   2drop ;

: word_t ( "name" -- )
  >in @ push   create   pop >in !   parse-name   dup , string,
;does:
  dup 1 cells + swap @ ( a n )
  pushing @ if
    stack @ emit ." psh = " type ." ; "
      change @ 1 + dup change !   put @ max put !   else
    stack @ tor   1 pops +!
      change @ 1 - dup change !   get @ min get !   then ;

: | ( ... -- )
  pushing @ if
    false pushing !   0 pops !   D:   else
    true pushing !   begin   pops @ while
      type ."  = " emit ." pop; "   1 pops -!   repeat
    then ;

: case ( -- )
  R:   0 change !   0 get !   0 put !
  D:   0 change !   0 get !   0 put !
  ." PRIM( " parse-name type ." , " ;

: break ( -- )
  ." , "
  R: get @ if   ." rget( " get @ negate . ." ); "   then
     put @ if   ." rput( " put @ . ." ); "   then
  D: get @ if   ." dget( " get @ negate . ." ); "   then
     put @ if   ." dput( " put @ . ." ); "   then
  ." ; )" cr ;

: {   7D parse type ;

word_t x   word_t y   word_t z   word_t iptr

case ABORT   { goto abort; } break
case HALT    { goto halt; } break
case EXIT    | R: iptr | break
case EXECUTE R: iptr | iptr | break

case FETCHRP { x = rptr; } x break
case FETCHRB { x = rbot; } x break
case FETCHRT { x = rtop; } x break
case STORERP | x | { rptr = x; rchk; } break
case STORERB | x | { rbot = x; rchk; } break
case STORERT | x | { rtop = x; rchk; } break

case FETCHDP { x = dptr; } x break
case FETCHDB { x = dbot; } x break
case FETCHDT { x = dtop; } x break
case STOREDP | x | { dptr = x; dchk; } break
case STOREDB | x | { dbot = x; dchk; } break
case STOREDT | x | { dtop = x; dchk; } break

case DROP | x | break
case DUP  | x | x x break
case NIP  | x y | y break
case SWAP | x y | y x break
case OVER | x y | x y x break
case TUCK | x y | y x y break
case ROT  | x y z | y z x break
case TOR  | x y z | z x y break

bye
